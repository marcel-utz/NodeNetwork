(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Code::Initialization:: *)
BeginPackage["NodeNetwork`"];

NodeNetwork::VersionNumber="0.0.5";

Print["Linear Nodal Network Analysis
Version ", NodeNetwork::VersionNumber, "
(c)2015-2017 Marcel Utz
marcel.utz@southampton.ac.uk"];



AdmittanceMatrix[nnodes_,BL_,OptionsPattern[{FullMatrix->False}]]:= Module[{l,A,Y,k,m,n},
Y=SparseArray[{},{nnodes,nnodes},0];
Do[ 
	If[Length[b]==2,  (* Two-pole admittance *)
		{k,m}= b [[1]];  (* pair of node defining the port *)
		Y[[k,m]] += -b[[2]];  (* b[[2]] is the port admittance of the two-pole *)
		Y[[m,k]] += -b[[2]];
		Y[[k,k]] += b[[2]];
		Y[[m,m]] += b[[2]];
	];
	If[Length[b]==3,  (* Four-pole admittance *)
		{k,l,m,n}= b[[1]]; (* two pairs of input nodes define the ports *)
		Do[Y[[x,x]] += b[[2]],{x,{k,l,m,n}}]; (* b[[2]] is the diagonal and b[[3]] the off-diagonal element of two-port admittance *)
		Y[[k,l]]+=-b[[2]];
		Y[[k,m]]+= b[[3]];
		Y[[k,n]]+= -b[[3]];
		Y[[l,k]]+= -b[[2]];
		Y[[l,m]]+= -b[[3]];
		Y[[l,n]]+= b[[3]];
		Y[[m,k]]+= b[[3]];
		Y[[m,l]]+= -b[[3]];
		Y[[m,n]]+= -b[[2]];
		Y[[n,k]]+= -b[[3]];
		Y[[n,l]]+= -b[[3]];
		Y[[n,m]]+= -b[[2]];
	];		
,{b,BL}] ;
If[OptionValue[FullMatrix]==True, Y, Y[[2;;,2;;]] ]
];


AdmittanceMatrix::usage="\!\(\*TagBox[StyleBox[\"AdmittanceMatrix\", Rule[FontFamily, \"Courier\"]], DisplayForm]\)\!\(\*TagBox[\"\\\"[\\\"\", DisplayForm]\)\!\(\*TagBox[Cell[BoxData[\(TraditionalForm\`\(\(\(n,\\ B\)\)]\)\)]], DisplayForm]\)\!\(\*TagBox[\"\\\" computes the nodal admittance matrix of dimensions \\\"\", DisplayForm]\)\!\(\*TagBox[Cell[BoxData[\(TraditionalForm\`\(\(\((n - 1)\)\)\\ \[Times]\\ \(\((n - 1)\)\)\)\)]], DisplayForm]\)\!\(\*TagBox[\"\\\" from the list of network branches \\\"\", DisplayForm]\)\!\(\*TagBox[Cell[BoxData[\(TraditionalForm\`B\)]], DisplayForm]\)\!\(\*TagBox[\"\\\". The branch list is an array of elements of the form \\\"\", DisplayForm]\)\!\(\*TagBox[Cell[BoxData[\(TraditionalForm\`\({\\ \(\({n, m}\)\),\\ Y}\)\)]], DisplayForm]\)\!\(\*TagBox[\"\\\", where \\\"\", DisplayForm]\)\!\(\*TagBox[Cell[BoxData[\(TraditionalForm\`n\)]], DisplayForm]\)\!\(\*TagBox[\"\\\" and \\\"\", DisplayForm]\)\!\(\*TagBox[Cell[BoxData[\(TraditionalForm\`m\)]], DisplayForm]\)\!\(\*TagBox[\"\\\" are the nodes the branch connects, and \\\"\", DisplayForm]\)\!\(\*TagBox[Cell[BoxData[\(TraditionalForm\`Y\)]], DisplayForm]\)\!\(\*TagBox[\"\\\" is the branch admittance. By definition, node 1 is assumed to be ground, and all voltages are taken with reference to it. By default, \\\"\", DisplayForm]\)\!\(\*TagBox[StyleBox[\"AdmittanceMatrix\", Rule[FontFamily, \"Courier\"]], DisplayForm]\)\!\(\*TagBox[\"\\\" returns the reduced matrix, without the row and column related to the ground node. This can be changed by setting the option \\\"\", DisplayForm]\)\!\(\*TagBox[StyleBox[\"FullMatrix\[Rule]False.\", Rule[FontFamily, \"Courier\"]], DisplayForm]\)"


PortMatrix[nnodes_,PL_,OptionsPattern[{FullMatrix->False}]]:= Module[{nports,A,P,k,m},
nports=Length[PL];
P=SparseArray[{},{nnodes,nports},0];
Do[
    {k,m}= PL[[b]];
	P[[k,b]]=1;
	P[[m,b]]=-1;
,{b,1,nports}] ;
If[OptionValue[FullMatrix]==True, P, P[[2;;]] ]
];


PortMatrix::usage="\!\(\*TagBox[StyleBox[\"PortMatrix\", Rule[FontFamily, \"Courier\"]], DisplayForm]\)\!\(\*TagBox[\"\\\"[\\\"\", DisplayForm]\)\!\(\*TagBox[Cell[BoxData[\(TraditionalForm\`\(\(\(n, P\)\)]\)\)]], DisplayForm]\)\!\(\*TagBox[\"\\\" computes the port adjancency matrix of dimensions \\\"\", DisplayForm]\)\!\(\*TagBox[Cell[BoxData[\(TraditionalForm\`\(\(\((n - 1)\)\)\\ \[Times]\\ p\)\)]], DisplayForm]\)\!\(\*TagBox[\"\\\" from the list of ports \\\"\", DisplayForm]\)\!\(\*TagBox[Cell[BoxData[\(TraditionalForm\`P\)]], DisplayForm]\)\!\(\*TagBox[\"\\\", assuming the network has \\\"\", DisplayForm]\)\!\(\*TagBox[Cell[BoxData[\(TraditionalForm\`n\)]], DisplayForm]\)\!\(\*TagBox[\"\\\" nodes and \\\"\", DisplayForm]\)\!\(\*TagBox[Cell[BoxData[\(TraditionalForm\`p\)]], DisplayForm]\)\!\(\*TagBox[\"\\\" ports. The list of ports is an array of \\\"\", DisplayForm]\)\!\(\*TagBox[Cell[BoxData[\(TraditionalForm\`p\)], Rule[FormatType, \"TraditionalForm\"]], DisplayForm]\)\!\(\*TagBox[\"\\\" elements of the form \\\"\", DisplayForm]\)\!\(\*TagBox[Cell[BoxData[\(TraditionalForm\`\({\\ \({n, m}\)}\)\)]], DisplayForm]\)\!\(\*TagBox[\"\\\", where \\\"\", DisplayForm]\)\!\(\*TagBox[Cell[BoxData[\(TraditionalForm\`n\)]], DisplayForm]\)\!\(\*TagBox[\"\\\" and \\\"\", DisplayForm]\)\!\(\*TagBox[Cell[BoxData[\(TraditionalForm\`m\)]], DisplayForm]\)\!\(\*TagBox[\"\\\" are the nodes the port connects. By default, \\\"\", DisplayForm]\)\!\(\*TagBox[StyleBox[\"PortMatrix\", Rule[FontFamily, \"Courier\"]], DisplayForm]\)\!\(\*TagBox[\"\\\" returns the reduced matrix, without the row corresponding to the ground node. This can be changed by setting the option \\\"\", DisplayForm]\)\!\(\*TagBox[StyleBox[\"FullMatrix\[Rule]False.\", Rule[FontFamily, \"Courier\"]], DisplayForm]\)"


(* Parametrize the resistive r=R/Zo contours *)
SmithR[r_, t_] := { (Cos[t] + r)/(1 + r), Sin[t]/(1 + r) } ;

(* Parametrize the reactive x=X/Zo contours *)
SmithX[x_, t_] := { Cos[t]/x +1, (Sin[t] + 1)/x } ;


SmithGrid[] := Module[ {SG={}},
SG= Table[ParametricPlot[Evaluate[SmithR[R,t]],{t,0,2Pi},DisplayFunction->Identity,PlotStyle->{Gray,Thickness[0.001]}],{R,0,1,0.2}] ;
SG=Join[SG,Table[ParametricPlot[Evaluate[SmithR[R,t]],{t,0,2Pi},DisplayFunction->Identity,PlotStyle->{Gray,Thickness[0.001]}],{R,1.5,2.5,0.5}]];
SG=Join[SG,Table[ParametricPlot[Evaluate[SmithR[R,t]],{t,0,2Pi},DisplayFunction->Identity,PlotStyle->{Gray,Thickness[0.001]}],{R,4,10,1}]];
SG=Join[SG,Table[ParametricPlot[Evaluate[SmithX[X+0.0001,t]],{t,-\[Pi]/2 ,ArcTan[-((-1+X^2)/(2X))]},DisplayFunction->Identity,PlotStyle->{Gray,Thickness[0.001]}],{X,-5.0001,0,0.25}]];

SG=Join[SG,Table[ParametricPlot[Evaluate[SmithX[X+0.0001,t]],{t,-\[Pi]/2,ArcTan[-((2 X)/(1+X^2)),(-1+X^2)/(1+X^2)]},DisplayFunction->Identity,PlotStyle->{Gray,Thickness[0.001]}],{X,0.0001,1,0.25}]];

SG=Join[SG,Table[ParametricPlot[Evaluate[SmithX[X+0.0001,t]],{t,3\[Pi]/2,ArcTan[-((2 X)/(1+X^2)),(-1+X^2)/(1+X^2)]},DisplayFunction->Identity,PlotStyle->{Gray,Thickness[0.001]}],{X,1.0001,5,0.25}]];

SG
]


SmithGrid::usage="\!\(\*TagBox[StyleBox[\"SmithGrid\", Rule[FontFamily, \"Courier\"]], DisplayForm]\)\!\(\*TagBox[\"\\\"[\\\"\", DisplayForm]\)\!\(\*TagBox[Cell[BoxData[\(TraditionalForm\`\(\\ ]\)\)]], DisplayForm]\)\!\(\*TagBox[\"\\\" generates a Smith chart grid pattern, which can be used together with polar plots of complex scattering parameters. Usually, the graph and the grid are combined by using:\\\\n\\\"\", DisplayForm]\)\!\(\*TagBox[StyleBox[\"Show[ParametricPlot[S[\[Omega]],{\[Omega],0,2\[Pi]}], SmithGrid[]]\", Rule[FontFamily, \"Courier\"]], DisplayForm]\)"


ZMatrix[nnodes_, BL_,PL_] := Module[{Y,P},
	P=PortMatrix[nnodes,PL];
	Y=AdmittanceMatrix[nnodes,BL];
	-Transpose[P].LinearSolve[Y,P]
];


SMatrix[nnodes_,Z0_,BL_,PL_] := Module[{Z,nports},
	nports=Length[PL];
	Z=ZMatrix[nnodes,BL,PL];
	LinearSolve[ Z-Z0 IdentityMatrix[nports],Z + Z0 IdentityMatrix[nports]]
];


ZMatrix::usage="\!\(\*TagBox[
StyleBox[\"ZMatrix\",
FontFamily->\"Courier\"],
DisplayForm]\)\!\(\*TagBox[\"\\\"[\\\"\", DisplayForm]\)\!\(\*TagBox[Cell[BoxData[ FormBox[ RowBox[{ RowBox[{\"n\", \",\", \"B\", \",\", \"P\"}], \"]\"}], TraditionalForm]]], DisplayForm]\)\!\(\*TagBox[\"\\\" computes the port impedance matrix of dimensions \\\"\", DisplayForm]\)\!\(\*TagBox[Cell[BoxData[ FormBox[ RowBox[{\"p\", \" \", \"\[Times]\", \" \", \"p\"}], TraditionalForm]]], DisplayForm]\)\!\(\*TagBox[\"\\\" from the list of branches \\\"\", DisplayForm]\)\!\(\*TagBox[Cell[BoxData[ FormBox[\"B\", TraditionalForm]]], DisplayForm]\)\!\(\*TagBox[\"\\\" and the list of ports \\\"\", DisplayForm]\)\!\(\*TagBox[Cell[BoxData[ FormBox[\"P\", TraditionalForm]]], DisplayForm]\)\!\(\*TagBox[\"\\\", assuming the network has \\\"\", DisplayForm]\)\!\(\*TagBox[Cell[BoxData[ FormBox[\"n\", TraditionalForm]]], DisplayForm]\)\!\(\*TagBox[\"\\\" nodes.\\\"\", DisplayForm]\)"


SMatrix::usage="\!\(\*TagBox[
StyleBox[\"SMatrix\",
FontFamily->\"Courier\"],
DisplayForm]\)\!\(\*TagBox[\"\\\"[\\\"\", DisplayForm]\)\!\(\*TagBox[Cell[BoxData[ FormBox[ RowBox[{ RowBox[{\"n\", \",\",  SubscriptBox[\"Z\", \"0\"], \",\", \"B\", \",\", \"P\"}], \"]\"}], TraditionalForm]]], DisplayForm]\)\!\(\*TagBox[\"\\\" computes the port scattering matrix (of dimension \\\"\", DisplayForm]\)\!\(\*TagBox[Cell[BoxData[ FormBox[ RowBox[{\"p\", \" \", \"\[Times]\", \" \", \"p\"}], TraditionalForm]]], DisplayForm]\)\!\(\*TagBox[\"\\\") from the list of branches \\\"\", DisplayForm]\)\!\(\*TagBox[Cell[BoxData[ FormBox[\"B\", TraditionalForm]]], DisplayForm]\)\!\(\*TagBox[\"\\\" and the list of ports \\\"\", DisplayForm]\)\!\(\*TagBox[Cell[BoxData[ FormBox[\"P\", TraditionalForm]]], DisplayForm]\)\!\(\*TagBox[\"\\\", assuming the network has \\\"\", DisplayForm]\)\!\(\*TagBox[Cell[BoxData[ FormBox[\"n\", TraditionalForm]]], DisplayForm]\)\!\(\*TagBox[\"\\\" nodes and \\\"\", DisplayForm]\)\!\(\*TagBox[Cell[BoxData[ FormBox[\"p\", TraditionalForm]]], DisplayForm]\)\!\(\*TagBox[\"\\\" ports with port impedance \\\"\", DisplayForm]\)\!\(\*TagBox[Cell[BoxData[ FormBox[ SubscriptBox[\"Z\", \"0\"], TraditionalForm]]], DisplayForm]\)\!\(\*TagBox[\"\\\".\\\"\", DisplayForm]\)"


LumpedComponentRules = {
	Resistor[R_]-> 1/R,
	Capacitor[C1_,DF_:0]->( \[Omega] C1 / (DF-I) ),
	Inductor[L_,R_:0]->1/(R+I \[Omega] L)} ;

TransmissionLineRules = {
	ShortedTL[\[Omega]0_,Z0_,R_:0] -> 1/(R+I Z0 Tan[\[Pi]/2  \[Omega]/\[Omega]0]),
	OpenTL[\[Omega]0_,Z0_,R_:0] -> 1/(R+I Z0 Cot[\[Pi]/2  \[Omega]/\[Omega]0]),
	TransmissionLine[\[Omega]0_,Z0_,Z1_] -> (1/Z0 (Z0 Cos[\[Pi]/2 \[Omega]/\[Omega]0] + I Z1 Sin[\[Pi]/2 \[Omega]/\[Omega]0])/(I Z0 Sin[\[Pi]/2 \[Omega]/\[Omega]0] + Z1 Cos[\[Pi]/2 \[Omega]/\[Omega]0]))
} ;

ComponentRules = Join[LumpedComponentRules,TransmissionLineRules];


BranchVoltage[nnodes_, BL_,PL_,Ip_] := Module[{Y,P,Vn,k,l,n,m},
	P=PortMatrix[nnodes,PL];
	Y=AdmittanceMatrix[nnodes,BL];
	Vn=-LinearSolve[Y,P].Ip;          (* These are the node voltages *)
	Vn = Prepend[Vn, 0 Ip[[1]] ];     (* Add the ground node to the list, Voltage is 0 by definition *)
	Table[
		If[Length[b]==2,
			{k,l}=b[[1]] ;
			Vn[[k]]-Vn[[l]],
		If[Length[b]==3,
			{k,l,m,n}=b[[1]] ;
			{Vn[[k]]-Vn[[l]],Vn[[m]]-Vn[[n]]}
			]],
	{b,BL}
	]
];


BranchCurrent[nnodes_, BL_,PL_,Ip_] := Module[{Vb},
	Vb=BranchVoltage[nnodes,BL,PL,Ip];
	Cases[BL,A_/;Length[A]==2][[;;,2]] Vb
];


BranchPower[nnodes_, BL_,PL_,Ip_] := Module[{Vb,P=0,j},
	Vb=BranchVoltage[nnodes,BL,PL,Ip];
	Table[
	  If[Length[BL[[j]] ]==2,
	     1/2 BL[[j,2]] Vb[[j]] Conjugate[Vb[[j]]],
	     If[Length[BL[[j]]]==3,
	        1/2 Conjugate[Vb[[j]]] . {{BL[[j,2]],BL[[j,3]]},{BL[[j,3]],BL[[j,2]]}} . Vb[[j]]]],
	{j,1,Length[BL]}]
];


BranchVoltage::usage="\!\(\*TagBox[
StyleBox[\"BranchVoltage\",
FontFamily->\"Courier\"],
DisplayForm]\)\!\(\*TagBox[\"\\\"[\\\"\", DisplayForm]\)\!\(\*TagBox[Cell[BoxData[ FormBox[ RowBox[{\" \",  RowBox[{\"n\", \",\", \" \", \"B\", \",\", \" \", \"P\", \",\", \" \", \"I\"}], \"]\"}], TraditionalForm]]], DisplayForm]\)\!\(\*TagBox[\"\\\", \\\"\", DisplayForm]\)\!\(\*TagBox[ StyleBox[\"BranchCurrent\", FontFamily->\"Courier\"], DisplayForm]\)\!\(\*TagBox[\"\\\"[\\\"\", DisplayForm]\)\!\(\*TagBox[Cell[BoxData[ FormBox[ RowBox[{\" \",  RowBox[{\"n\", \",\", \" \", \"B\", \",\", \" \", \"P\", \",\", \" \", \"I\"}], \"]\"}], TraditionalForm]]], DisplayForm]\)\!\(\*TagBox[\"\\\", and \\\"\", DisplayForm]\)\!\(\*TagBox[ StyleBox[\"BranchPower\", FontFamily->\"Courier\"], DisplayForm]\)\!\(\*TagBox[\"\\\"[\\\"\", DisplayForm]\)\!\(\*TagBox[Cell[BoxData[ FormBox[ RowBox[{\" \",  RowBox[{\"n\", \",\", \" \", \"B\", \",\", \" \", \"P\", \",\", \" \", \"I\"}], \"]\"}], TraditionalForm]]], DisplayForm]\)\!\(\*TagBox[\"\\\" return a vector of voltage differences, currents, or average power disspation accross each branch in the branch list \\\"\", DisplayForm]\)\!\(\*TagBox[Cell[BoxData[ FormBox[\"B\", TraditionalForm]]], DisplayForm]\)\!\(\*TagBox[\"\\\", assuming a network of \\\"\", DisplayForm]\)\!\(\*TagBox[Cell[BoxData[ FormBox[\"n\", TraditionalForm]]], DisplayForm]\)\!\(\*TagBox[\"\\\" nodes, and currents \\\"\", DisplayForm]\)\!\(\*TagBox[Cell[BoxData[ FormBox[\"I\", TraditionalForm]]], DisplayForm]\)\!\(\*TagBox[\"\\\" in the ports. \\\"\", DisplayForm]\)\!\(\*TagBox[ StyleBox[\"BranchPower\", FontFamily->\"Courier\"], DisplayForm]\)\!\(\*TagBox[\"\\\"[ ] returns a complex value, with the real and imaginary parts representing the dissipated and stored power, respectively.\\\"\", DisplayForm]\)"


BranchCurrent::usage=BranchVoltage::usage; BranchPower::usage=BranchVoltage::usage;


(* ::Input::Initialization:: *)
EndPackage[]



